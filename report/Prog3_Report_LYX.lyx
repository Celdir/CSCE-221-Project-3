#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass article
\use_default_options false
\maintain_unincluded_children false
\language english
\language_package none
\inputencoding iso8859-15
\fontencoding default
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 2
\use_package amssymb 0
\use_package cancel 0
\use_package esint 1
\use_package mathdots 0
\use_package mathtools 0
\use_package mhchem 0
\use_package stackrel 0
\use_package stmaryrd 0
\use_package undertilde 0
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title

\series bold
Programming 2 Assignment
\end_layout

\begin_layout Author
Michael Earl, Gerald Hu 
\begin_inset Newline newline
\end_inset

 
\begin_inset Newline newline
\end_inset

 CSCE 221-200
\end_layout

\begin_layout Date
April 11, 2016
\end_layout

\begin_layout Section*
Introduction
\end_layout

\begin_layout Standard
\noindent
The purpose of this assignment was to analyze the theoretical and actual
 performance of several common sorting algorithms discussed in class.
 The project implemented bubble sort, two 
\begin_inset Quotes eld
\end_inset

slow sorting
\begin_inset Quotes erd
\end_inset

 algorithms (insertion and selection sort), and two 
\begin_inset Quotes eld
\end_inset

fast sorting
\begin_inset Quotes erd
\end_inset

 algorithms (mergesort and quicksort).
 The running time of these algorithms was analyzed for several types of
 data: sorted data, reverse-sorted data, randomized data, and data with
 many similar elements.
 [TODO - summary of results + what we learned]
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Section*
Implementation Details
\end_layout

\begin_layout Standard
\noindent
All sorting algorithms took random-access iterators to the first and last
 elements of the container, and a comparator.
 
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
\noindent
Bubble Sort is a simple sorting algorithm.
 It compares a set of two elements that are next to each other, and if the
 elements in the bubble are out of order, they are swapped.
 This set traverses the entire container from start to end, then starts
 from the beginning again, repeating until there are no more swaps to make.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
\noindent
Selection Sort is one of the two 
\begin_inset Quotes eld
\end_inset

slow
\begin_inset Quotes erd
\end_inset

 sorting algorithms.
 It traverses the entire container searching for the smallest element, then
 swaps that element into the first position.
 Then it searches the remainder of the container for the next-smallest element,
 then swaps that element into the first position of the remainder.
 On its 
\begin_inset Formula $i$
\end_inset

th traversal, it will swap the smallest element into the 
\begin_inset Formula $i$
\end_inset

th position.
 This process continues 
\begin_inset Formula $n$
\end_inset

 times, at which point there is no more 
\begin_inset Quotes erd
\end_inset

remainder
\begin_inset Quotes erd
\end_inset

 of the container to traverse.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
\noindent
Insertion Sort is the other of the two 
\begin_inset Quotes eld
\end_inset

slow
\begin_inset Quotes erd
\end_inset

 sorting algorithms.
 It traverses the entire container 
\begin_inset Formula $n$
\end_inset

 times.
 In each traversal, for each step 
\begin_inset Formula $i$
\end_inset

, if 
\begin_inset Formula $i$
\end_inset

 is not the first element, and if 
\begin_inset Formula $i$
\end_inset

 and 
\begin_inset Formula $i-1$
\end_inset

 are out of order, the two are swapped, swapping the element into an 
\begin_inset Quotes erd
\end_inset

already-sorted
\begin_inset Quotes erd
\end_inset

 portion of the container.
 Each traversal will grow the already-sorted portion, until all the data
 is in the sorted portion.
 
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
\noindent
Mergesort is one of the two 
\begin_inset Quotes eld
\end_inset

fast
\begin_inset Quotes erd
\end_inset

 sorting algorithms.
 It splits the input data into two subarrays, and recursively splits each
 of those subarrays into two subarrays, repeating the splitting process
 until each subarray is of size
\begin_inset Formula $<$
\end_inset

2.
 These subarrays are then sorted in sets of two, and the resulting sorted
 data is put into an array and returned.
 The returned sorted data is merged with more data using the same merge
 function, until fully-sorted data is returned.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
\noindent
Quicksort is the other of the two 
\begin_inset Quotes eld
\end_inset

fast
\begin_inset Quotes erd
\end_inset

 sorting algorithms.
 It randomly selects an element of the data to use as a 
\begin_inset Quotes eld
\end_inset

pivot
\begin_inset Quotes erd
\end_inset

 , and traverses the entire container.
 It moves all elements less than the pivot to before the pivot's position,
 and moves all elements greater than the pivot to after the pivot's position,
 all of which is done in-place.
 This places the pivot in the proper position.
 Then, quicksort is recursively called, once on the set of elements less
 than the pivot, and once on the set of elements greater than the pivot.
 
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
\noindent
The skeleton of timing.cpp was provided by the instructors.
 The timing function was already implemented for randomly sorted input data;
 we modified it to analyze sorted and reverse-sorted data, as well as data
 with many similar elements.
 The timing function relies on high_resolution_clock; given a sorting function
 and a number 
\begin_inset Formula $n$
\end_inset

, the timing function would generate a vector with 
\begin_inset Formula $n$
\end_inset

 elements in it.
 Then, the timing function would try to sort the vector using the specified
 sorting algorithm.
 This process was repeated for increasing sizes of 
\begin_inset Formula $n$
\end_inset

, and repeated 10 times at each 
\begin_inset Formula $n$
\end_inset

 to ensure an accurate average time.
 [TODO - what we learned]
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Section*
Theoretical Analysis
\end_layout

\begin_layout Standard
\noindent
Bubble Sort is 
\begin_inset Formula $O(n^{2})$
\end_inset

 average and worst case.
 It will force the largest element to the end after 
\begin_inset Formula $n$
\end_inset

 comparisons; then it will repeat this for the 
\begin_inset Formula $n-1$
\end_inset

 smallest element, then the 
\begin_inset Formula $n-2$
\end_inset

 smallest element, and so on, repeating 
\begin_inset Formula $n$
\end_inset

 times in total.
 
\begin_inset Formula $n$
\end_inset

 traversals and 
\begin_inset Formula $n$
\end_inset

 comparisons/swaps at each traversal results in 
\begin_inset Formula $O(n^{2})$
\end_inset

 time.
 Bubble Sort's best case is 
\begin_inset Formula $O(n)$
\end_inset

, in the case that it's already sorted.
 It traverses the list once and makes 
\begin_inset Formula $n$
\end_inset

 comparisons, but does not do any swaps or any further traversals.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
\noindent
Selection Sort is 
\begin_inset Formula $O(n^{2})$
\end_inset

 in all cases.
 In searching for the smallest element, it will traverse 
\begin_inset Formula $n$
\end_inset

 elements and make 
\begin_inset Formula $n$
\end_inset

 comparisons, before forcing the smallest element to the start.
 It then repeats this process for a sublist of size 
\begin_inset Formula $n-1$
\end_inset

, then 
\begin_inset Formula $n-2$
\end_inset

...
\begin_inset Formula $n-n$
\end_inset

.
 
\begin_inset Formula $\sum_{i=0}^{n}i=(i)(i+1)/2$
\end_inset

, which is 
\begin_inset Formula $O(n^{2})$
\end_inset

 behavior.
 Furthermore, it will always search for the smallest element, regardless
 of whether it needs to be swapped or not, and will perform all traversals
 regardless of what data type it's given.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
\noindent
Insertion Sort is 
\begin_inset Formula $O(n^{2})$
\end_inset

 average and worst case, for similar reasons as Selection Sort: it will
 traverse a list of size 
\begin_inset Formula $n$
\end_inset

, then size 
\begin_inset Formula $n-1$
\end_inset

, then 
\begin_inset Formula $n-2$
\end_inset

...
\begin_inset Formula $n-n$
\end_inset

.
 Unlike Selection Sort, Insertion Sort is 
\begin_inset Formula $O(n)$
\end_inset

, in the best case that it is already sorted, as it will only traverse the
 list once.
 
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
\noindent
Mergesort is 
\begin_inset Formula $O(nlog(n))$
\end_inset

 in all cases.
 At each step, the problem is split in half, until it reaches the smallest
 possible subproblem; it will take 
\begin_inset Formula $O(logn)$
\end_inset

 splits to reach the base level, and 
\begin_inset Formula $O(n)$
\end_inset

 to merge all the data back together.
 There is not a 
\begin_inset Quotes eld
\end_inset

best case
\begin_inset Quotes erd
\end_inset

 input type, as mergesort will perform the same operations regardless of
 the data it's given.
 
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
\noindent
Quicksort is 
\begin_inset Formula $O(nlog(n))$
\end_inset

 average case and best case, and 
\begin_inset Formula $O(n^{2})$
\end_inset

 in a rare worst case.
 The best case of quicksort is 
\begin_inset Formula $O(nlogn)$
\end_inset

 due to an inherent limit on comparison-based sorting algorithms.
 Assuming an 
\begin_inset Quotes eld
\end_inset

average case
\begin_inset Quotes erd
\end_inset

 where the pivots selected give equal (or close to equal) sized sublists,
 it will take 
\begin_inset Formula $O(logn)$
\end_inset

 splits to reach the base level, and 
\begin_inset Formula $O(n)$
\end_inset

 to merge all the data back together.
 The worst case is if every pivot chosen is a bad selection, splitting into
 a subproblem of size 1 and size 
\begin_inset Formula $(n-1)$
\end_inset

, which is then split into a subproblem of size 1 and size 
\begin_inset Formula $(n-2)$
\end_inset

, so on....resulting in 
\begin_inset Formula $O(n)$
\end_inset

 splits.
 
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Section*
Experimental Setup
\end_layout

\begin_layout Standard
Timing tests were conducted using the provided timing.cpp, compiled with
 the provided makefile's commands.
 Compilation was done on Michael's desktop, with G++ version 5.3.0.
 Compilation was set to the C++14 standard, with the -G flag enabled and
 O2 optimization level, warnings set to -Wall -Werror (warn all and all
 warnings treated as compilation errors), and dependencies flagged with
 -MMD (auto-generate dependencies).
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
\noindent
Tests were run on Michael's desktop, which runs Arch Linux x86_64 version
 4.4.5-1.
 It has 8 total gigabytes of RAM.
 It uses an AMD FX-8350 8-Core processor, with a clock speed of 4 GHz.
 
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
\noindent
Timing functions output timing results for input sizes that were powers
 of 2, starting from 2 itself, and ending at a maximum size specified by
 the user.
 Each step of the timing was repeated 10 times, and the average of each
 result taken.
 Bubble Sort went up to a maximum input size of 32768 
\begin_inset Formula $(2^{15})$
\end_inset

 elements; Insertion and Selection sorts went up to a maximum input size
 of 131072 
\begin_inset Formula $(2^{17})$
\end_inset

 elements; and Quicksort and Mergesort went up to a maximum input size of
 4194304 
\begin_inset Formula $(2^{22})$
\end_inset

 elements.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
\noindent
Four data types were used in testing: sorted data, reverse-sorted data,
 randomly-sorted data, and data with 
\begin_inset Quotes eld
\end_inset

few unique elements
\begin_inset Quotes erd
\end_inset

.
 For our purposes, 
\begin_inset Quotes eld
\end_inset

data with few unique elements
\begin_inset Quotes erd
\end_inset

 was assumed to mean 
\begin_inset Quotes eld
\end_inset

data where a lot of the elements are the same
\begin_inset Quotes erd
\end_inset

; the input data generated consisted mostly of 1s, with a few 2s spaced
 out in the data.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Section*
Results and Discussion
\end_layout

\begin_layout Standard
[TODO - this]
\end_layout

\begin_layout Section*
Conclusion
\end_layout

\begin_layout Standard
This assignment achieved a few main goals.
 First and foremost, it deepened our understanding of the way maps and binary
 search trees work.
 It also introduced, in a practical way, how to use AVL trees.
 And it verified the theoretical discussions held in class about the performance
 of functions of the ADT implementation.
 The advantages of the AVL tree were concretely seen in the performance
 difference between the regular binary search tree and the AVL tree.
 From the timing results obtained in this assignment, it can be seen that
 AVL trees are better than or on par with binary search trees in every situation.
 Overall, this assignment as a whole gave needed practice in coding as well
 as reinforced concepts that were learned in class.
 
\end_layout

\begin_layout Standard
This assignment showed the differences in runtime between various sorting
 algorithms, highlighting which ones were theoretically more efficient,
 and which ones actually performed better in practice.
 Quicksort, like the discussions in class, consistently performed well and
 sorted quickly; Insertion Sort and Bubble Sort ran quickly on already-sorted
 data, but performed worse in other areas.
 Out of the slow sorts, Insertion was the best, and Bubble was the worst
 in most cases.
 Out of all sorting algorithms, Quicksort and Mergesort performed similarly,
 but Quicksort was a bit faster.
 
\end_layout

\end_body
\end_document
